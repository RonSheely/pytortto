Sqrt:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.sqrt(..., out=...)
  forward_outplace: xp.sqrt(...)
  save_for_backward: yt0
  params:
  backward: ["gd0 / (yd0 * 2)"]


Exp:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.exp(..., out=...)
  forward_outplace: xp.exp(...)
  save_for_backward: yt0
  params:
  backward: ["gd0 * yd0"]


Tan:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.tan(..., out=...)
  forward_outplace: xp.tan(...)
  save_for_backward: yt0
  params:
  backward: ["gd0 * (1 + yd0 * yd0)"]


Tanh:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.tanh(..., out=...)
  forward_outplace: xp.tanh(...)
  save_for_backward: yt0
  params:
  backward: ["gd0 * (1 - yd0 * yd0)"]


Sigmoid:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.exp(-xp.logaddexp(0, -..., out=...), out=...)
  forward_outplace: xp.exp(-xp.logaddexp(0, -...))
  save_for_backward: yt0
  params:
  backward: ["gd0 * yd0 * (1 - yd0)"]


Sign:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: xp.sign(...)
  save_for_backward:
  params:
  backward: ["xp.zeros_like(gd0)"]


Neg:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.negative(..., out=...)
  forward_outplace: xp.negative(...)
  save_for_backward:
  params:
  backward: ["-gd0"]


Add:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.add(..., ///, out=...)
  forward_outplace: xp.add(..., ///)
  save_for_backward:
  params: shape
  backward: ["reverse_broadcast(gd0, x0_shape)"]


Sub:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.subtract(..., ///, out=...)
  forward_outplace: xp.subtract(..., ///)
  save_for_backward:
  params: shape
  backward: ["reverse_broadcast(gd0, x0_shape)", "-reverse_broadcast(gd0, x1_shape)"]


Sin:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.sin(..., out=...)
  forward_outplace: xp.sin(...)
  save_for_backward: xt0
  params:
  backward: ["gd0 * xp.cos(xd0)"]


Cos:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.cos(..., out=...)
  forward_outplace: xp.cos(...)
  save_for_backward: xt0
  params:
  backward: ["-gd0 * xp.sin(xd0)"]


Log:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.log(..., out=...)
  forward_outplace: xp.log(...)
  save_for_backward: xt0
  params:
  backward: ["gd0 / xd0"]


Abs:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.abs(..., out=...)
  forward_outplace: xp.abs(...)
  save_for_backward: xt0
  params:
  backward: ["gd0 * xp.sign(xd0)"]


Pow:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: xp.power(..., ///, out=...)
  forward_outplace: xp.power(..., ///)
  save_for_backward: xt0, xt1, yt0
  params: shape
  backward: ["reverse_broadcast(gd0 * xd1 * yd0 / xd0, x0_shape)", "reverse_broadcast(gd0 * xp.log(xd0) * yd0, x1_shape)"]

#Mul:
#  num_inputs: 2
#  num_outputs: 1
#  allow_inplace: True
#  forward_inplace: xp.multiply(xd..., xd///, out=xd...)
#  selective_copy:
#  forward_outplace: xp.multiply(xd..., xd///)
#  save_for_backward: xt0, xt1
#  params: shape
#  backward: ["reverse_broadcast(gd0 * xd1, xd0_shape)", "reverse_broadcast(gd0 * xd0, xd1_shape)"]