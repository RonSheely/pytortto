Sqrt:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.sqrt($0, out=$0)"]
  forward_outplace: ["@ = xp.sqrt($0)"]
  save_for_backward: yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 / (yd0 * 2)"]

Exp:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.exp($0, out=$0)"]
  forward_outplace: ["@ = xp.exp($0)"]
  save_for_backward: yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * yd0"]

Tan:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.tan($0, out=$0)"]
  forward_outplace: ["@ = xp.tan($0)"]
  save_for_backward: yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * (1 + yd0 * yd0)"]

Tanh:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.tanh($0, out=$0)"]
  forward_outplace: ["@ = xp.tanh($0)"]
  save_for_backward: yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * (1 - yd0 * yd0)"]

Sigmoid:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.exp(-xp.logaddexp(0, -$0, out=$0), out=$0)"]
  forward_outplace: ["@ = xp.exp(-xp.logaddexp(0, -$0))"]
  save_for_backward: yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * yd0 * (1 - yd0)"]

Sign:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.sign($0)"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = xp.zeros_like($0)"]

Neg:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.negative($0, out=$0)"]
  forward_outplace: ["@ = xp.negative($0)"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = -$0"]

Add:
  comment:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.add($0, $1, out=$0)"]
  forward_outplace: ["@ = xp.add($0, $1)"]
  save_for_backward:
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = reverse_broadcast($0, xd0_shape)", "@ = reverse_broadcast($0, xd1_shape)"]

Sub:
  comment:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.subtract($0, $1, out=$0)"]
  forward_outplace: ["@ = xp.subtract($0, $1)"]
  save_for_backward:
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = reverse_broadcast($0, xd0_shape)", "@ = -reverse_broadcast($0, xd1_shape)"]

Sin:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.sin($0, out=$0)"]
  forward_outplace: ["@ = xp.sin($0)"]
  save_for_backward: xt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * xp.cos(xd0)"]

Cos:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.cos($0, out=$0)"]
  forward_outplace: ["@ = xp.cos($0)"]
  save_for_backward: xt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * -xp.sin(xd0)"]

Log:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.log($0, out=$0)"]
  forward_outplace: ["@ = xp.log($0)"]
  save_for_backward: xt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 / xd0"]

Abs:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.abs($0, out=$0)"]
  forward_outplace: ["@ = xp.abs($0)"]
  save_for_backward: xt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = $0 * xp.sign(xd0)"]

Pow:
  comment:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.power($0, $1, out=$0)"]
  forward_outplace: ["@ = xp.power($0, $1)"]
  save_for_backward: xt0, xt1, yt0
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = reverse_broadcast($0 * xd1 * yd0 / xd0, xd0_shape)", "@ = reverse_broadcast($0 * xp.log(xd0) * yd0, xd1_shape)"]

Mul:
  comment:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.multiply($0, $1, out=$0)"]
  forward_outplace: ["@ = xp.multiply($0, $1)"]
  save_for_backward: xt0, xt1
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = reverse_broadcast($0 * xd1, xd0_shape)", "@ = reverse_broadcast($0 * xd0, xd1_shape)"]

Div:
  comment:
  num_inputs: 2
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.divide($0, $1, out=$0)"]
  forward_outplace: ["@ = xp.divide($0, $1)"]
  save_for_backward: xt0, xt1
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = reverse_broadcast($0 / xd1, xd0_shape)", "@ = reverse_broadcast(-$0 * xd0 / (xd1 * xd1), xd1_shape)"]

Clamp:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: True
  forward_inplace: ["xp.clip($0, a_min=params['min'], a_max=ctx.params['max'], out=$0)"]
  forward_outplace: ["@ = xp.clip($0, a_min=params['min'], a_max=ctx.params['max'])"]
  save_for_backward: xt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["\n>>> @ = $0
              \n>>> if params['min'] is not None:
              \n>>>     $0[xd0 < params['min']] = 0
              \n>>> if params['max'] is not None:
              \n>>>     $0[xd0 > params['max']] = 0"]

Max0:
  comment: "\n>>> # optimize it?
            \n>>> # https://stackoverflow.com/questions/46840848/numpy-how-to-use-argmax-results-to-get-the-actual-max"
  num_inputs: 1
  num_outputs: 2
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.max($0, axis=params['dim'], keepdims=params['keepdim'])",

                     "\n>>> argmax = xp.argmax($0, axis=params['dim'], keepdims=params['keepdim'])
                      \n>>> @ = argmax"]
  save_for_backward:
  save_params: argmax
  save_class_params: shape
  backward_common:
  backward: ["\n>>> idx = xp.ogrid[[slice(ax) for ax in argmax.shape]]
              \n>>> if params['keepdim']:
              \n>>>     idx[params['dim']] = argmax
              \n>>> else:
              \n>>>     idx.insert(params['dim'], argmax)
              \n>>> @ = xp.zeros(xd0_shape, dtype=$0.dtype)
              \n>>> @[tuple(idx)] = $0"]

Max1:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.max($0)"]
  save_for_backward: xt0, yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["\n>>> @ = xp.zeros_like(xd0)
              \n>>> @[xd0 == yd0] = $0"]


Maximum:
  comment: "# optimize it?"
  num_inputs: 2
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.maximum($0, $1)"]
  save_for_backward: xt0, xt1
  save_params:
  save_class_params: shape
  backward_common: "\n>>> maximum = xp.maximum(xd0, xd1)
                    \n>>> xd0_equal_max_ind = maximum == xd0
                    \n>>> xd1_equal_max_ind = maximum == xd1
                    \n>>> both_equal_max_ind = xd0_equal_max_ind & xd1_equal_max_ind"

  backward: ["\n>>> @ = $0.copy() if ctx.needs_input_grad[1] else $0
              \n>>> @[~xd0_equal_max_ind] = 0
              \n>>> @[both_equal_max_ind] /= 2
              \n>>> @ = reverse_broadcast(@, xd0_shape)",

             "\n>>> @ = $0
              \n>>> @[~xd1_equal_max_ind] = 0
              \n>>> @[both_equal_max_ind] /= 2
              \n>>> @ = reverse_broadcast(@, xd1_shape)"]

Min0:
  comment: "\n>>> # optimize it?
            \n>>> # https://stackoverflow.com/questions/46840848/numpy-how-to-use-argmax-results-to-get-the-actual-max"
  num_inputs: 1
  num_outputs: 2
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.min($0, axis=params['dim'], keepdims=params['keepdim'])",

                     "\n>>> argmin = xp.argmin($0, axis=params['dim'], keepdims=params['keepdim'])
                      \n>>> @ = argmin"]
  save_for_backward:
  save_params: argmin
  save_class_params: shape
  backward_common:
  backward: ["\n>>> idx = xp.ogrid[[slice(ax) for ax in argmin.shape]]
              \n>>> if params['keepdim']:
              \n>>>     idx[params['dim']] = argmin
              \n>>> else:
              \n>>>     idx.insert(params['dim'], argmin)
              \n>>> @ = xp.zeros(xd0_shape, dtype=$0.dtype)
              \n>>> @[tuple(idx)] = $0"]

Min1:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.min($0)"]
  save_for_backward: xt0, yt0
  save_params:
  save_class_params:
  backward_common:
  backward: ["\n>>> @ = xp.zeros_like(xd0)
              \n>>> @[xd0 == yd0] = $0"]


Minimum:
  comment: "# optimize it?"
  num_inputs: 2
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.minimum($0, $1)"]
  save_for_backward: xt0, xt1
  save_params:
  save_class_params: shape
  backward_common: "\n>>> minimum = xp.minimum(xd0, xd1)
                    \n>>> xd0_equal_min_ind = minimum == xd0
                    \n>>> xd1_equal_min_ind = minimum == xd1
                    \n>>> both_equal_min_ind = xd0_equal_min_ind & xd1_equal_min_ind"

  backward: ["\n>>> @ = $0.copy() if ctx.needs_input_grad[1] else $0
              \n>>> @[~xd0_equal_min_ind] = 0
              \n>>> @[both_equal_min_ind] /= 2
              \n>>> @ = reverse_broadcast(@, xd0_shape)",

             "\n>>> @ = $0
              \n>>> @[~xd1_equal_min_ind] = 0
              \n>>> @[both_equal_min_ind] /= 2
              \n>>> @ = reverse_broadcast(@, xd1_shape)"]

View:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = $0.reshape(params['shape'])"]
  save_for_backward:
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["@ = $0.reshape(xd0_shape)"]

Slice:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = $0[params['key']]"]
  save_for_backward:
  save_params:
  save_class_params: shape
  backward_common:
  backward: ["\n>>> @ = xp.zeros(xd0_shape, dtype=$0.dtype)
              \n>>> @[params['key']] = $0"]

Permute:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.transpose($0, params['dims'])"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = xp.transpose($0, axes=tt.np.argsort(params['dims']))"]

Transpose:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.swapaxes($0, params['dim0'], params['dim1'])"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = xp.swapaxes($0, params['dim0'], params['dim1'])"]


Squeeze:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["\n>>> if params['dim'].__class__ is int:
                      \n>>>     dim = (dim,)
                      \n>>> if dim is None:
                      \n>>>     dim = tuple(range($0.ndim))
                      \n>>> squeeze_dims = tuple(i for i in dim if $0.shape[i] == 1)
                      \n>>> if len(squeeze_dims) == 0:
                      \n>>>     @ = $0
                      \n>>> else:
                      \n>>>     @ = xp.squeeze($0, squeeze_dims)"]
  save_for_backward:
  save_params: squeeze_dims
  save_class_params:
  backward_common:
  backward: ["@ = xp.expand_dims($0, squeeze_dims)"]

Unsqueeze:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["@ = xp.expand_dims($0, params['dim'])"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["@ = xp.squeeze($0, params['dim'])"]

Repeat:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["\n>>> @ = xp.tile($0, params['sizes'])
                      \n>>> yd0_strides = yd0.strides"]
  save_for_backward:
  save_params: yd0_strides
  save_class_params: shape
  backward_common:
  backward: ["\n>>> xd0_ndim = len(xd0_shape)
              \n>>> leading_dims = tuple(range(len(params['sizes'])))
              \n>>> target_shape = sizes + xd0_shape
              \n>>> target_strides = yd0_strides[:-xd0_ndim] + tuple(
              \n>>>     xd0_shape[i] * yd0_strides[i - xd0_ndim] for i in range(xd0_ndim)) + yd0_strides[-xd0_ndim:]
              \n>>> @ = xp.lib.stride_tricks.as_strided($0, shape=target_shape, strides=target_strides).sum(leading_dims)"]

ToCopy:
  comment:
  num_inputs: 1
  num_outputs: 1
  allow_inplace: False
  forward_inplace:
  forward_outplace: ["\n>>> if xp is cp:
                      \n>>>     if params['target_device'] == 'cuda':
                      \n>>>         return xt0
                      \n>>>     else:
                      \n>>>         @ = $0.get()
                      \n>>> else:
                      \n>>>     if target_device == 'cpu':
                      \n>>>         return xt0
                      \n>>>     else:
                      \n>>>         #if not cupy_is_loaded:
                      \n>>>          #   raise RuntimeError('cupy not installed, can\\'t use cuda')
                      \n>>>         @ = cparray($0)"]
  save_for_backward:
  save_params:
  save_class_params:
  backward_common:
  backward: ["\n>>> if params['target_device'] == 'cpu':
              \n>>>     @ = cp.array($0)
              \n>>> else:
              \n>>>     @ = $0.get()"]

